\newpage
\section{NTRU Cryptosystem}
\label{chapter2}
\textit{}
%---- the scope of this chapter}}

The NTRU Cryptosystem is the most practical known lattice-based cryptosystem and arguably the most popular lattice-based cryptosystem. Before we discuss the algorithm details, we need to build up the theoretical set up. And for the sake of simplicity we will omit the mathematical proof and leave only the ready-to-use results. 
\newline
\newline
\textbf{Definition\ 2.1: }  \emph{Let\ v\ $\in \mathbb{R}^n$\ be\ a\ vector\ and\ A $\in \mathbb{R}^{n\times n}$\ be\ a\ matrix. Then,\ we\ define\ $A^*_v$\ :=\ (v,\ Av,..., A$^{n-1}$v).\ Furthermore,\ we\ define\ the\ matrix\ T, where\ T\ is: }
\begin{center}
        $$\left[\begin{array}{ccc|c}
                0 & \cdots & 0 & 1 \\ \hline
                \ddots & \ & \ & 0 \\
                \ & I & \ & \vdots \\
                \ & \ & \ddots & 0
\end{array}\right] $$
\end{center}
\emph{I is an rotation matrix, hence\ we\ have\ $T^*_v$\ is\ the\ matrix\ whose\ i-th\ column\ is\ equal\ to\ v\ rotated\ by\ I}
\newline
\newline
\textbf{Lemma\ 2.2:\ } \emph{For\ any\ two\ vectors\ f,\ g\ $\in \mathbb{R}^n$,\ we\ have}
\newline
\emph{(i).\ $T^*_f$g\ =\ $T^*_g$f}
\newline
\emph{(ii).\ T$\cdot T^*_f$\ =\ $T^*_f \cdot$ T}
\newline
\emph{(iii).\ $T^*_f\cdot T^*_g$\ =\ $T^*_{T^*_fg}$}
\newline
\newline
\textbf{Definition\ 2.3:\ } \emph{A\ q-ary\ lattice\ $\mathcal{L}$ = $\Lambda_{q}(A)$\ is\ a\ \textbf{convolutional\ modular\ lattice}\ A\ $\in \mathbb{Z}^{n \times 2 n}$\ and $\left(\begin{array}{l}{T x} \\ {T_{y}}\end{array}\right) \in \mathcal{L}$\ for\ all\ $\left(\begin{array}{l}{x} \\ {y}\end{array}\right) \in \mathcal{L}$}
\newline
\newline
\textbf{Definition\ 2.4:\ } \emph{Let\ n,\ d,\ $\in$\ $\mathbb{N}$\ and\ d\ <\ n.\ A\ vector\ f\ $\in$\ $\mathbb{Z}^n$\ is\ called\ a\ d\textbf{-vector}\ if\ f\ has\ exactly\ d\ negative\ and\ d\ +\ 1\ positive\ nonzero\ entries.}
\newline
\newline


\subsection{NTRU Key Generation}

The NTRU cryptosystem requires the generation of both a public and a private key before hand. The formal expression and a mathematical proof of its correctness is provided as follows:  
\begin{algorithm}[t]
        \caption{NTRU Key Generation}
        \begin{algorithmic}[1] %每行显示行号
            \Require Prime n $\in$ $\mathbb{N}$, modulus q $\in$ $\mathbb{N}$, p $\in$ $\mathbb{N}$ with p < q, weight bound d $\in$ $\mathbb{N}$
            \Ensure A private key $\left(\begin{array}{l}{f} \\ {g}\end{array}\right) \in \mathbb{Z}^{2 n}$ and a public key $h \in \mathbb{Z}_{q}^{n}$.
             \State \textbf{choose} two \emph{d}-vectors \emph{f}$^'$, \emph{g} $\in_{R}\{p, 0,-p\}^{n}$
             \State \emph{f} $\leftarrow$ \emph{f}$^'$ + \emph{e}$_1$
                \If {$\pi_{q}\left(T_{f}^{*}\right) \notin \mathrm{Gl}_{n}\left(\mathbb{Z}_{q}\right)$}
                    \State \textbf{goto} step 1
                \EndIf
            \State h $\leftarrow$ $\left(T_{f}^{*}\right)^{-1} g \bmod q$
            \State \Return{$\left(\left(\begin{array}{l}{f} \\ {g}\end{array}\right), h\right)$}  
        \end{algorithmic}
    \end{algorithm}
%---- How to detirmine the LCI
\newpage
\textbf{Proposition 2.4: }\emph{Let $\left(\left(\begin{array}{l}{f} \\ {g}\end{array}\right),\ h\right)$\ be\ a\ key\ pair\ generated by NTRU Key Generation Algorithm and $A :=\left(T_{f}^{*} T_{g}^{*}\right)$. Then, \newline
(i). $\Lambda_{q}(A)$ is the smallest convolutional modular lattice containing  $\left(\begin{array}{l}{f} \\ {g}\end{array}\right)$. \newline
(ii). $T_{f}^{*} \equiv I(\bmod p)$ and $T_{g}^{*} \equiv \mathbf{0}(\bmod p)$.\newline
(iii). If $\Lambda_{q}(A)=\mathcal{L}\left(A^{\prime}\right),$ the hermite normal form of $A^{\prime}$ is given by\newline
\begin{center}
    H = 
  \begin{bmatrix}
   I & 0 \\
   $T^*_h$ & qI 
  \end{bmatrix} \tag{1}
\end{center}
}
\emph{Proof: } Since we chose \emph{f}$^'$, \emph{g} $\in_{R}\{p, 0,-p\}^{n}$, \emph{f}$^'$ and \emph{g} are divisible by p. As in State 2 in the pseudocode, \emph{f} := \emph{f}$^'$ + \emph{e}$_1$, \emph{f} $\equiv$ \emph{e}$_1$ mod p. Since $T^*_f$ and $T^*_g$ are the matrices whose i-th column is equal to \emph{f} or \emph{g} rotated by I, the result of congruence shown by (ii) is obvious.
\newline
$\quad$ For $(i),$ note that $x \in \Lambda_{q}(A)$ if there exist $y \in \mathbb{Z}^{n}$ and $z \in \mathbb{Z}^{m}$ with $x=A^{T} y+q z$ . Since\newline
\begin{equation}
    A^{T} y=\left(\begin{array}{c}{T_{f}^{*}} \\ {T_{g}^{*}}\end{array}\right) y=\sum_{i=0}^{n-1}\left(\begin{array}{c}{T^{i} f} \\ {T^{i} g}\end{array}\right) \cdot y_{i}
\end{equation}
and\newline
\begin{equation}
    \left(\begin{array}{l}{z_{1}} \\ {z_{2}}\end{array}\right) \in \mathbb{Z}^{m} \Leftrightarrow\left(\begin{array}{l}{T z_{1}} \\ {T z_{2}}\end{array}\right) \in \mathbb{Z}^{m}
\end{equation}
Then $\Lambda_{q}(A)$ is convolutional. Also, if any convolutional modular lattice contains $\left(\begin{array}{l}{f} \\ {g}\end{array}\right),$ it must contain all $\mathbb{Z}$ -linear combinations of the form $(2.1) .$ For (iii), three preliminaries have to be introduced first: \newline
$\bullet$ The vector $\left(\begin{array}{l}{f} \\ {g}\end{array}\right)$ is contained in $\mathcal{L}(H)$.\newline
$\bullet$ The lattice $\mathcal{L}(H)$ is convolutional.\newline
$\bullet$The inclusion $\mathcal{L}(H) \subseteq \Lambda_{q}(A)$ holds.\newline
First, we need $\left(\begin{array}{c}{x} \\ {y}\end{array}\right) \in \mathbb{Z}^{2 n}$ such that $H \cdot\left(\begin{array}{c}{x} \\ {y}\end{array}\right)=\left(\begin{array}{l}{f} \\ {g}\end{array}\right) .$ Since application of $H$ does not change $x,$ then the x we need becomes $x=f .$ For $y :=q^{-1}\left(g-T_{h}^{*} f\right)$, \newline
\begin{equation}
    H \cdot\left(\begin{array}{l}{x} \\ {y}\end{array}\right)=\left(\begin{array}{c}{f} \\ {T_{h}^{*} f+q I y}\end{array}\right)=\left(\begin{array}{l}{f} \\ {g}\end{array}\right)
\end{equation}
By Lemma 2.2 and the definition of h, we have:
\begin{equation}
    T_{h}^{*} f=T_{f}^{*} h=T_{f}^{*} \cdot\left(T_{f}^{*}\right)^{-1} g \equiv g \quad(\bmod q)
\end{equation}
Now we have shown that $g-T_{h}^{*} f$ is an integer multiple of $q$, so y is an integral.
\newline
From (i), we know that $\Lambda_{q}(A) \subseteq \mathcal{L}(H)$. Then we need to show that $\mathcal{L}(H)$ is convolutional. We can see that\newline
\begin{equation}
    \left(\begin{array}{l}{x} \\ {y}\end{array}\right) \in \mathcal{L}(H) \Leftrightarrow \exists \overline{y} \in \mathbb{Z}^{n} : H \cdot\left(\begin{array}{l}{x} \\ {\overline{y}}\end{array}\right)=\left(\begin{array}{l}{x} \\ {y}\end{array}\right) \Leftrightarrow T_{h}^{*} x+q I \overline{y}=y
\end{equation}
Let\newline
\begin{equation}
    x^{\prime} :=Tx
\end{equation}
\begin{equation}
    y^{\prime} :=q^{-1}\left(T y-T_{h}^{*} x^{\prime}\right)
\end{equation}
Then we can calculate that $H \cdot\left(\begin{array}{c}{x^{\prime}} \\ {y^{\prime}}\end{array}\right)=\left(\begin{array}{l}{T x} \\ {T y}\end{array}\right)$. Then we can calculate\newline
\begin{equation}
    T y \stackrel{(2.5)}{=} T\left(T_{h}^{*} x+q I \overline{y}\right) \equiv T T_{h}^{*} x \stackrel{2.2}{=} T_{h}^{*} T x=T_{h}^{*} T x=T_{h}^{*} x^{\prime} \quad(\bmod q)
\end{equation}
So, $y^{\prime}$ is integral, $\mathcal{L}(H)$ is convolutional. \newline
At last, det($\mathcal{L}(H)$) = q$^n$, and that $\mathcal{L}(H) \supseteq \Lambda_{q}(A)$, so $\mathcal{L}(H)$ can not contain any further points since both lattices have the same density.

\subsection{NTRU Encryption}

The following is the psedocode of NTRU encryption algorithm\newline
\begin{algorithm}[h]
        \caption{NTRU Encryption}
        \begin{algorithmic}[1] %每行显示行号
            \Require Prime n $\in$ $\mathbb{N}$, modulus q $\in$ $\mathbb{N}$, weight bound d $\in$ $\mathbb{N}$, public key $h \in \mathbb{Z}_{q}^{n}$, \emph{d}-vector message m $\in\{1,0,-1\}^{n}$.
            \Ensure Ciphertext $c \in \mathbb{Z}_{q}^{n}$.
             \State \textbf{choose} a \emph{d}-vector $c \in \mathbb{Z}_{q}^{n}$
             \State h \leftarrow $T_{f}^{*} g$
             \State \Return{$m+T_{h}^{*} r \bmod q$}  
        \end{algorithmic}
    \end{algorithm} 
    \newline
    \newline
    \newpage
\textbf{Definition 2.9: } \emph{Let $a, b \in \mathbb{Z}^{n}$ be two integral vectors and $A \in \mathbb{Z}^{n \times n}$ a matrix of rank: n. We say that a is congruent b modulo $A$ if $A^{-1}(a-b) \in \mathbb{Z}^{n} .$ We then write $a \equiv b$ (mod A)}
\newline
\newline
The following algorithm helps to reduce a vector modulo a lower triangular matrix $A$. 
\begin{algorithm}[h]
        \caption{Matrix Reduction}
        \begin{algorithmic}[1] %每行显示行号
            \Require A lower triangular matrix $A=\left(a_{i j}\right) \in \mathbb{Z}^{n \times n}$ of rank $n$ and $b \in \mathbb{Z}^{n}$ .
            \Ensure A vector $\overline{b} \in \mathbb{Z}^{n}$ such that $0 \leq \overline{b}_{i}<a_{i j}$ for all $i$ and $b \equiv \overline{b}(\bmod A)$. 
             \For{$i \in [1,n]$}
                \State b $\leftarrow$ $b-\left\lfloor a_{i i} / b_{i}\right\rfloor \cdot\left(a_{1, i} \cdots a_{n, i}\right)^{T}$
             \EndFor
             \State \Return{b}  
        \end{algorithmic}
    \end{algorithm} 

\newline
\newline
\textbf{Definition 2.10: }\emph{Denote the output of Matrix-Reduction by a mod A.}
\newline
\newline
\textbf{Lemma 2.11: }\emph{For two integral d-vectors $r, m \in\{1,0,-1\}^{n}$
\begin{equation}
    \left(\begin{array}{c}{-r} \\ {m}\end{array}\right) \bmod \left(\begin{array}{cc}{I} & {0} \\ {T_{h}^{*}} & {q I}\end{array}\right)=\left(\begin{array}{c}{0} \\ {\left(m+T_{h}^{*} r\right) \bmod q}\end{array}\right)
\end{equation}
}
    

\subsection{NTRU Decryption}
The psedocode for the decryption of NTRU ciphertext is as follows:
\begin{algorithm}[h]
        \caption{NTRU Decryption}
        \begin{algorithmic}[1] %每行显示行号
            \Require prime $n \in \mathbb{N},$ modulus $q \in \mathbb{N}, p \in \mathbb{N}$ with $p<q,$ weight bound $d \in \mathbb{N},$ private key $\left(\begin{array}{l}{f} \\ {g}\end{array}\right) \in \mathbb{Z}_{q}^{2 n}$ and a ciphertext $c \in \mathbb{Z}_{q}^{n}$.
            \Ensure plaintext $m \in\{1,0,-1\}^{n}$
            \State $\overline{v} \leftarrow T_{f}^{*} c$
             \For{$i \in [1,n]$}
                \State $v_{i} \leftarrow \underset{\pi_{q}(v)=\tilde{v}_{i}}{\arg \min }|v|$
             \EndFor
             \State \Return{$\left(v_{1} \cdots v_{n}\right) \bmod p$}  
        \end{algorithmic}
    \end{algorithm} 
    \newpage
We now prove that, With a parameter choice satisfying 8 d p+4 p+2<q, the NTRU Cryptosystem works correctly.
\newline
\emph{Proof: } Assume that $c$ is a ciphertext generated by NTRU Encryption. Then,\newline
\begin{equation}
    T_{f}^{*} \cdot c \equiv T_{f}^{*} m+T_{f}^{*} T_{h}^{*} r \stackrel{3.7}{=} T_{f}^{*} m+T_{T_{f}^{*}h}^{*} r \equiv T_{f}^{*} m+T_{g}^{*} r \quad(\bmod q)
\end{equation}
Hence, let us inspect the vector $v$ more closely. Its $i$ -th entry is given by the formula\newline
\begin{equation}
    v_{i}=\sum_{j=1}^{n}\left(\left(T_{f}^{*}\right)_{i j} m_{j}+\left(T_{g}^{*}\right)_{i j} r_{j}\right)=\sum_{j=1}^{n}\left(\left(T^{j-1} f\right)_{i} m_{j}+\left(T^{j-1} g\right)_{i} r_{j}\right) = \sum_{j=1}^{n}\left(f_{i-j+1} m_{j}+g_{i-j+1} r_{j}\right)
\end{equation}
We write $f^{\prime}=f-e_{1}$ as in the NTRU Key Generation step 1 . Estimating the absolute value of $v_{i},$ the worst case would certainly be
\begin{equation}
    f_{i-j+1}^{\prime}=\left\{\begin{aligned}-p & { ;} \quad m_{j}=-1 \\ p & { ;} \quad m_{j}=1 \end{aligned}\right.\quad And\quad g_{i-j+1}=\left\{\begin{array}{rlr}{-p} & { ;} & {r_{j}=-1} \\ {p} & { ;} & {r_{j} = 1}\end{array}\right.
\end{equation}
since $f=f^{\prime}+e_{1},$ we obtain the condition 
\begin{equation}
    \left|w_{i}\right| \leq(d p+(p+1)+d p)+((d+1) p+d p)=4 d p+2 p+1
\end{equation}
which yields the condition $8 d p+4 p+2<q$ if we want the absolute values to be bounded by $q / 2$, indicating a successful decryption.